package com.pilotpax.skywriter;

/*
Copyright (c) 2012 Daniel Van Blerkom

This file is part of SkyWriter

SkyWriter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SkyWriter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SkyWriter.  If not, see <http://www.gnu.org/licenses/>.
*/

import org.bukkit.block.Block;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;

public class MatrixLetter {
	
	private static int oldAge = 20;
	private static int drawThreshold = 10;
	
	private static int charMatrixHeight = 8;
	private static int charMatrixWidth = 8;
	
	private static int charMatrix[] = {
		0x7F, 0x88, 0x88, 0x88, 0x7F, 0x00, 0x00, 0x00,  // A
		0xFF, 0x91, 0x91, 0x91, 0x6E, 0x00, 0x00, 0x00,  // B
		0x7E, 0x81, 0x81, 0x81, 0x42, 0x00, 0x00, 0x00, 
		0xFF, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 
		0xFF, 0x91, 0x91, 0x91, 0x81, 0x00, 0x00, 0x00, 
		0xFF, 0x90, 0x90, 0x90, 0x80, 0x00, 0x00, 0x00, 
		0x7E, 0x81, 0x89, 0x89, 0x4E, 0x00, 0x00, 0x00, 
		0xFF, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x00, 0x00, 
		0x81, 0x81, 0xFF, 0x81, 0x81, 0x00, 0x00, 0x00, 
		0x06, 0x01, 0x01, 0x01, 0xFE, 0x00, 0x00, 0x00, 
		0xFF, 0x18, 0x24, 0x42, 0x81, 0x00, 0x00, 0x00, 
		0xFF, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
		0xFF, 0x40, 0x30, 0x40, 0xFF, 0x00, 0x00, 0x00, 
		0xFF, 0x40, 0x30, 0x08, 0xFF, 0x00, 0x00, 0x00, 
		0x7E, 0x81, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 
		0xFF, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x00, 
		0x7E, 0x81, 0x85, 0x82, 0x7D, 0x00, 0x00, 0x00, 
		0xFF, 0x88, 0x8C, 0x8A, 0x71, 0x00, 0x00, 0x00, 
		0x61, 0x91, 0x91, 0x91, 0x8E, 0x00, 0x00, 0x00, 
		0x80, 0x80, 0xFF, 0x80, 0x80, 0x00, 0x00, 0x00, 
		0xFE, 0x01, 0x01, 0x01, 0xFE, 0x00, 0x00, 0x00, 
		0xF0, 0x0C, 0x03, 0x0C, 0xF0, 0x00, 0x00, 0x00, 
		0xFF, 0x02, 0x0C, 0x02, 0xFF, 0x00, 0x00, 0x00, 
		0xC3, 0x24, 0x18, 0x24, 0xC3, 0x00, 0x00, 0x00, 
		0xE0, 0x10, 0x0F, 0x10, 0xE0, 0x00, 0x00, 0x00, 
		0x83, 0x85, 0x99, 0xA1, 0xC1, 0x00, 0x00, 0x00,  // Z	
		0x06, 0x29, 0x29, 0x29, 0x1F, 0x00, 0x00, 0x00,  // a
		0xFF, 0x09, 0x11, 0x11, 0x0E, 0x00, 0x00, 0x00,  // b
		0x1E, 0x21, 0x21, 0x21, 0x12, 0x00, 0x00, 0x00, 
		0x0E, 0x11, 0x11, 0x09, 0xFF, 0x00, 0x00, 0x00, 
		0x0E, 0x15, 0x15, 0x15, 0x0C, 0x00, 0x00, 0x00, 
		0x08, 0x7F, 0x88, 0x80, 0x40, 0x00, 0x00, 0x00, 
		0x30, 0x49, 0x49, 0x49, 0x7E, 0x00, 0x00, 0x00, 
		0xFF, 0x08, 0x10, 0x10, 0x0F, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x02, 0x01, 0x21, 0xBE, 0x00, 0x00, 0x00, 0x00, 
		0xFF, 0x04, 0x0A, 0x11, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x81, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 
		0x3F, 0x20, 0x18, 0x20, 0x1F, 0x00, 0x00, 0x00, 
		0x3F, 0x10, 0x20, 0x20, 0x1F, 0x00, 0x00, 0x00, 
		0x0E, 0x11, 0x11, 0x11, 0x0E, 0x00, 0x00, 0x00, 
		0x3F, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00, 
		0x10, 0x28, 0x28, 0x18, 0x3F, 0x00, 0x00, 0x00, 
		0x1F, 0x08, 0x10, 0x10, 0x08, 0x00, 0x00, 0x00, 
		0x09, 0x15, 0x15, 0x15, 0x02, 0x00, 0x00, 0x00, 
		0x20, 0xFE, 0x21, 0x01, 0x02, 0x00, 0x00, 0x00, 
		0x1E, 0x01, 0x01, 0x02, 0x1F, 0x00, 0x00, 0x00, 
		0x1C, 0x02, 0x01, 0x02, 0x1C, 0x00, 0x00, 0x00, 
		0x1E, 0x01, 0x0E, 0x01, 0x1E, 0x00, 0x00, 0x00, 
		0x11, 0x0A, 0x04, 0x0A, 0x11, 0x00, 0x00, 0x00, 
		0x00, 0x39, 0x05, 0x05, 0x3E, 0x00, 0x00, 0x00, 
		0x11, 0x13, 0x15, 0x19, 0x11, 0x00, 0x00, 0x00,  // z
		0x00, 0x41, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00,  // 1
		0x43, 0x85, 0x89, 0x91, 0x61, 0x00, 0x00, 0x00,  // 2
		0x42, 0x81, 0x91, 0x91, 0x6E, 0x00, 0x00, 0x00, 
		0x18, 0x28, 0x48, 0xFF, 0x08, 0x00, 0x00, 0x00, 
		0xF2, 0x91, 0x91, 0x91, 0x8E, 0x00, 0x00, 0x00, 
		0x1E, 0x29, 0x49, 0x89, 0x86, 0x00, 0x00, 0x00, 
		0x80, 0x8F, 0x90, 0xA0, 0xC0, 0x00, 0x00, 0x00, 
		0x6E, 0x91, 0x91, 0x91, 0x6E, 0x00, 0x00, 0x00, 
		0x70, 0x89, 0x89, 0x8A, 0x7C, 0x00, 0x00, 0x00,  // 9
		0x60, 0x80, 0x8D, 0x90, 0x60, 0x00, 0x00, 0x00,  // ?
		0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00,  // !
		0x7E, 0x89, 0x91, 0xA1, 0x7E, 0x00, 0x00, 0x00,  // 0
		0x66, 0x89, 0x8F, 0x81, 0x7E, 0x00, 0x00, 0x00,  // @
		0x24, 0xFF, 0x24, 0xFF, 0x24, 0x00, 0x00, 0x00,  // #
		0x76, 0x89, 0x95, 0x62, 0x05, 0x00, 0x00, 0x00,  // &
		0x00, 0x3C, 0x42, 0x81, 0x00, 0x00, 0x00, 0x00,  // (
		0x00, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,  // )
		0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00,  // +
		0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,  // -
		0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00   // =
	};
	
	private static char charMatrixIndex[] = {
		'A', 'B', 'C', 'D', 'E', 'F',
		'G', 'H', 'I', 'J', 'K', 'L',
		'M', 'N', 'O', 'P', 'Q', 'R',
		'S', 'T', 'U', 'V', 'W', 'X',
		'Y', 'Z', 
		'a', 'b', 'c', 'd', 'e', 'f',
		'g', 'h', 'i', 'j', 'k', 'l',
		'm', 'n', 'o', 'p', 'q', 'r',
		's', 't', 'u', 'v', 'w', 'x',
		'y', 'z', 
		'1', '2', '3', '4', '5', '6',
		'7', '8', '9', '?', '!', '0',
		'@', '#', '&', '(', ')', '+',
		'-', '='
	};
	
	private static int undefChar = 61;
	
	char myChar;
	int matrixIndex;
	int[][] myMatrix;
	Location myLoc;
	int myTime;
	
	public void setLetter(char c) {
		myChar = c;
		matrixIndex = -1;
		for (int x = 0; x < charMatrixIndex.length; x++) {
			if (c == charMatrixIndex[x]) {
				matrixIndex = x;
				break;
			}
		}
		if (matrixIndex == -1) { matrixIndex = undefChar; }  // point to '?' if undefined character
		
		myMatrix = new int[charMatrixHeight][charMatrixWidth];
		for (int x = 0; x < charMatrixHeight; x++) {
			for (int z = 0; z < charMatrixWidth; z++) {
				if ((charMatrix[matrixIndex*charMatrixHeight + x] & (1 << z)) != 0) {
					myMatrix[x][z] = 100;
				} else {
					myMatrix[x][z] = 0;
				}
			}
		}	
	}
	
	public void setLocation(Location loc) {
		myLoc = loc;
	}
	
	public void setTime(int t) {
		myTime = t;
	}
	
	// sort of a one-sided gaussian blur kernel...
	public void disperseCloud() {
		int[][] convolve = new int[charMatrixHeight][charMatrixWidth];
		
		for (int z = 0; z < charMatrixWidth; z++) {
			for (int x = 0; x < charMatrixHeight; x++) {
				convolve[x][z] =  (int) ( (((double) myMatrix[x][z]) * 0.57) +
						(x>0 ? ((double) myMatrix[x-1][z]) * 0.21 : 0.0) +
						(x>1 ? ((double) myMatrix[x-2][z]) * 0.01 : 0.0) );						
			}
		}
		myMatrix = convolve;
	}

	public void incrementTime() {
		myTime = myTime + 1;
		eraseLetter();
		if (myTime < oldAge) {
			disperseCloud();
			makeLetter();
		}
	}
	
	public boolean isLetterOld() {
		if (myTime < oldAge) {
			return false;  
		} else {
			return true;   // delete this letter
		}
	}
	
	public int getTime() {
		return myTime;
	}
	
	public void printLetter() {
		for (int x = 0; x < charMatrixHeight; x++) {
			for (int y = 0; y < charMatrixWidth; y++) {
				if (myMatrix[x][y] != 0) {
					System.out.print('*');
				} else {
					System.out.print(' ');
				}
			}
			System.out.println("");			
		}
	}	

	public Location nextLocation() {
    	World world = myLoc.getWorld();   	 
    	int xloc = myLoc.getBlockX();   
    	int yloc = myLoc.getBlockY();    
    	int zloc = myLoc.getBlockZ();

    	return(new Location(world, xloc + charMatrixHeight, yloc, zloc));
	}
	
	private byte mapTimeToColor(int value) {
		if (value > 50) {
			return((byte) 0x3);  // blue
		} else if (value > 20) {
			return((byte) 0x8);  // Light gray
		} else {
			return((byte) 0x0);  // White
		}
	}
	
	public void makeLetter() {
    	World world = myLoc.getWorld();   	 
    	int xloc = myLoc.getBlockX();   
    	int yloc = myLoc.getBlockY();    
    	int zloc = myLoc.getBlockZ();
		
		for (int x = 0; x < charMatrixHeight; x++) {
			for (int z = 0; z < charMatrixWidth; z++) {
				if (myMatrix[x][z] > drawThreshold) {
            		Block b = world.getBlockAt(xloc+x,yloc,zloc+z);
            		if (b.getType() == Material.AIR) {
            			b.setType(Material.WOOL);
            			b.setData(mapTimeToColor(myMatrix[x][z]));  
            		} else {
            			myMatrix[x][z] = 0;
            		}
				} 
			}
		}
	}
	
	public void eraseLetter() {
    	World world = myLoc.getWorld();   	 
    	int xloc = myLoc.getBlockX();   
    	int yloc = myLoc.getBlockY();    
    	int zloc = myLoc.getBlockZ();
		
		for (int x = 0; x < charMatrixHeight; x++) {
			for (int z = 0; z < charMatrixWidth; z++) {
				if (myMatrix[x][z] > drawThreshold) {
            		Block b = world.getBlockAt(xloc+x,yloc,zloc+z);
            		if (b.getType() == Material.WOOL) {
            			b.setType(Material.AIR);
            		} 
				}
			}
		}		
	}
		
	public MatrixLetter(char c, Location loc) {
		setLetter(c);
		setLocation(loc);
		setTime(0);
		makeLetter();
	}
}
