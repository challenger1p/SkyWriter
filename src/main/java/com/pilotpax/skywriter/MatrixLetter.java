package com.pilotpax.skywriter;

/*
Copyright (c) 2012 Daniel Van Blerkom

This file is part of SkyWriter

SkyWriter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SkyWriter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SkyWriter.  If not, see <http://www.gnu.org/licenses/>.
*/

import org.bukkit.block.Block;
import org.bukkit.DyeColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;

public class MatrixLetter {
	
	private static int startDispersal = 5;
	private static int oldAge = 25;
	private static int drawThreshold = 10;
	
	private static int charMatrixHeight = 8;
	private static int charMatrixWidth = 8;
	
	private static int charMatrix[] = {
		0x7F, 0x88, 0x88, 0x88, 0x7F, 0x00, 0x00, 0x00,  // A
		0xFF, 0x91, 0x91, 0x91, 0x6E, 0x00, 0x00, 0x00,  // B
		0x7E, 0x81, 0x81, 0x81, 0x42, 0x00, 0x00, 0x00, 
		0xFF, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 
		0xFF, 0x91, 0x91, 0x91, 0x81, 0x00, 0x00, 0x00, 
		0xFF, 0x90, 0x90, 0x90, 0x80, 0x00, 0x00, 0x00, 
		0x7E, 0x81, 0x89, 0x89, 0x4E, 0x00, 0x00, 0x00, 
		0xFF, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x00, 0x00, 
		0x81, 0x81, 0xFF, 0x81, 0x81, 0x00, 0x00, 0x00, 
		0x06, 0x01, 0x01, 0x01, 0xFE, 0x00, 0x00, 0x00, 
		0xFF, 0x18, 0x24, 0x42, 0x81, 0x00, 0x00, 0x00, 
		0xFF, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
		0xFF, 0x40, 0x30, 0x40, 0xFF, 0x00, 0x00, 0x00, 
		0xFF, 0x40, 0x30, 0x08, 0xFF, 0x00, 0x00, 0x00, 
		0x7E, 0x81, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 
		0xFF, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x00, 
		0x7E, 0x81, 0x85, 0x82, 0x7D, 0x00, 0x00, 0x00, 
		0xFF, 0x88, 0x8C, 0x8A, 0x71, 0x00, 0x00, 0x00, 
		0x61, 0x91, 0x91, 0x91, 0x8E, 0x00, 0x00, 0x00, 
		0x80, 0x80, 0xFF, 0x80, 0x80, 0x00, 0x00, 0x00, 
		0xFE, 0x01, 0x01, 0x01, 0xFE, 0x00, 0x00, 0x00, 
		0xF0, 0x0C, 0x03, 0x0C, 0xF0, 0x00, 0x00, 0x00, 
		0xFF, 0x02, 0x0C, 0x02, 0xFF, 0x00, 0x00, 0x00, 
		0xC3, 0x24, 0x18, 0x24, 0xC3, 0x00, 0x00, 0x00, 
		0xE0, 0x10, 0x0F, 0x10, 0xE0, 0x00, 0x00, 0x00, 
		0x83, 0x85, 0x99, 0xA1, 0xC1, 0x00, 0x00, 0x00,  // Z	
		0x06, 0x29, 0x29, 0x29, 0x1F, 0x00, 0x00, 0x00,  // a
		0xFF, 0x09, 0x11, 0x11, 0x0E, 0x00, 0x00, 0x00,  // b
		0x1E, 0x21, 0x21, 0x21, 0x12, 0x00, 0x00, 0x00, 
		0x0E, 0x11, 0x11, 0x09, 0xFF, 0x00, 0x00, 0x00, 
		0x0E, 0x15, 0x15, 0x15, 0x0C, 0x00, 0x00, 0x00, 
		0x08, 0x7F, 0x88, 0x80, 0x40, 0x00, 0x00, 0x00, 
		0x30, 0x49, 0x49, 0x49, 0x7E, 0x00, 0x00, 0x00, 
		0xFF, 0x08, 0x10, 0x10, 0x0F, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x02, 0x01, 0x21, 0xBE, 0x00, 0x00, 0x00, 0x00, 
		0xFF, 0x04, 0x0A, 0x11, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x81, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 
		0x3F, 0x20, 0x18, 0x20, 0x1F, 0x00, 0x00, 0x00, 
		0x3F, 0x10, 0x20, 0x20, 0x1F, 0x00, 0x00, 0x00, 
		0x0E, 0x11, 0x11, 0x11, 0x0E, 0x00, 0x00, 0x00, 
		0x3F, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00, 
		0x10, 0x28, 0x28, 0x18, 0x3F, 0x00, 0x00, 0x00, 
		0x1F, 0x08, 0x10, 0x10, 0x08, 0x00, 0x00, 0x00, 
		0x09, 0x15, 0x15, 0x15, 0x02, 0x00, 0x00, 0x00, 
		0x20, 0xFE, 0x21, 0x01, 0x02, 0x00, 0x00, 0x00, 
		0x1E, 0x01, 0x01, 0x02, 0x1F, 0x00, 0x00, 0x00, 
		0x1C, 0x02, 0x01, 0x02, 0x1C, 0x00, 0x00, 0x00, 
		0x1E, 0x01, 0x0E, 0x01, 0x1E, 0x00, 0x00, 0x00, 
		0x11, 0x0A, 0x04, 0x0A, 0x11, 0x00, 0x00, 0x00, 
		0x00, 0x39, 0x05, 0x05, 0x3E, 0x00, 0x00, 0x00, 
		0x11, 0x13, 0x15, 0x19, 0x11, 0x00, 0x00, 0x00,  // z
		0x00, 0x41, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00,  // 1
		0x43, 0x85, 0x89, 0x91, 0x61, 0x00, 0x00, 0x00,  // 2
		0x42, 0x81, 0x91, 0x91, 0x6E, 0x00, 0x00, 0x00, 
		0x18, 0x28, 0x48, 0xFF, 0x08, 0x00, 0x00, 0x00, 
		0xF2, 0x91, 0x91, 0x91, 0x8E, 0x00, 0x00, 0x00, 
		0x1E, 0x29, 0x49, 0x89, 0x86, 0x00, 0x00, 0x00, 
		0x80, 0x8F, 0x90, 0xA0, 0xC0, 0x00, 0x00, 0x00, 
		0x6E, 0x91, 0x91, 0x91, 0x6E, 0x00, 0x00, 0x00, 
		0x70, 0x89, 0x89, 0x8A, 0x7C, 0x00, 0x00, 0x00,  // 9
		0x60, 0x80, 0x8D, 0x90, 0x60, 0x00, 0x00, 0x00,  // ?
		0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00,  // !
		0x7E, 0x89, 0x91, 0xA1, 0x7E, 0x00, 0x00, 0x00,  // 0
		0x66, 0x89, 0x8F, 0x81, 0x7E, 0x00, 0x00, 0x00,  // @
		0x24, 0xFF, 0x24, 0xFF, 0x24, 0x00, 0x00, 0x00,  // #
		0x76, 0x89, 0x95, 0x62, 0x05, 0x00, 0x00, 0x00,  // &
		0x00, 0x3C, 0x42, 0x81, 0x00, 0x00, 0x00, 0x00,  // (
		0x00, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,  // )
		0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00,  // +
		0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,  // -
		0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00,  // =
		0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,  // '
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // space
		0x70, 0x8C, 0x42, 0x21, 0x42, 0x8C, 0x70, 0x00   // heart
	};
	
	private static char charMatrixIndex[] = {
		'A', 'B', 'C', 'D', 'E', 'F',
		'G', 'H', 'I', 'J', 'K', 'L',
		'M', 'N', 'O', 'P', 'Q', 'R',
		'S', 'T', 'U', 'V', 'W', 'X',
		'Y', 'Z', 
		'a', 'b', 'c', 'd', 'e', 'f',
		'g', 'h', 'i', 'j', 'k', 'l',
		'm', 'n', 'o', 'p', 'q', 'r',
		's', 't', 'u', 'v', 'w', 'x',
		'y', 'z', 
		'1', '2', '3', '4', '5', '6',
		'7', '8', '9', '?', '!', '0',
		'@', '#', '&', '(', ')', '+',
		'-', '=', '\'', ' ', '\u2665'
	};
	
	private static int undefChar = 61;
	
	char myChar;                // character for this letter
	int matrixIndex;            // pointer to character list
	int[][] myMatrix;           // 8x8 integer matrix holding "pixel" values, which degrade as letter disperses
	Location myLoc;             // location of this letter
	int myTime;                 // age of this letter
	int myTick;                 // clock ticks for speed adjustments
	Orientation myOrientation;  // letter orientation
	int myAgeSpeed;             // scales standard aging by this factor
	boolean myDisperse;         // true if letter will disperse over time
	Material myMaterial;        // the type of material this letter is made of
	boolean myUpright;          // true if the letter should be upright
	
	public void setLetter(char c) {
		myChar = c;
		matrixIndex = -1;
		for (int x = 0; x < charMatrixIndex.length; x++) {
			if (c == charMatrixIndex[x]) {
				matrixIndex = x;
				break;
			}
		}
		if (matrixIndex == -1) { matrixIndex = undefChar; }  // point to '?' if undefined character
		
		myMatrix = new int[charMatrixHeight][charMatrixWidth];
		for (int x = 0; x < charMatrixHeight; x++) {
			for (int z = 0; z < charMatrixWidth; z++) {
				if ((charMatrix[matrixIndex*charMatrixHeight + x] & (1 << z)) != 0) {
					myMatrix[x][z] = 100;
				} else {
					myMatrix[x][z] = 0;
				}
			}
		}	
	}
	
	public void setLocation(Location loc) {
		myLoc = loc;
	}
	
	public void setTime(int t) {
		myTime = t;
		myTick = 0;
	}
	
	public void setOrientation(Orientation o) {
		myOrientation = o;
	}
	
	// sort of a one-sided gaussian blur kernel...
	public void disperseCloud() {
		int[][] convolve = new int[charMatrixHeight][charMatrixWidth];
		
		for (int z = 0; z < charMatrixWidth; z++) {
			for (int x = 0; x < charMatrixHeight; x++) {
				convolve[x][z] =  (int) ( (((double) myMatrix[x][z]) * 0.57) +
						(x>0 ? ((double) myMatrix[x-1][z]) * 0.21 : 0.0) +
						(x>1 ? ((double) myMatrix[x-2][z]) * 0.01 : 0.0) );						
			}
		}
		myMatrix = convolve;
	}

	public void incrementTime() {
		if (myTick < (myAgeSpeed-1)) {
			myTick++;
		} else {
			myTick = 0;
			myTime = myTime + 1;
			if (myTime > startDispersal && myDisperse) {
				eraseLetter();
				if (myTime < oldAge) {
					disperseCloud();
					makeLetter();
				}
			}
		}
	}
	
	public boolean isLetterOld() {
		if (myTime < oldAge) {
			return false;  
		} else {
			return myDisperse;   // delete this letter if disperse is true
		}
	}
	
	public boolean isDisperse() {
		return myDisperse;
	}
	
	public int getTime() {
		return myTime;
	}
	
	public Orientation getOrientation() {
		return myOrientation;
	}
	
	public void printLetter() {
		for (int x = 0; x < charMatrixHeight; x++) {
			for (int y = 0; y < charMatrixWidth; y++) {
				if (myMatrix[x][y] != 0) {
					System.out.print('*');
				} else {
					System.out.print(' ');
				}
			}
			System.out.println("");			
		}
	}	

	public Location nextLocation() {
		World world = myLoc.getWorld();   	 
		int xloc = myLoc.getBlockX();   
		int yloc = myLoc.getBlockY();    
		int zloc = myLoc.getBlockZ();

		switch (myOrientation) {
		case XMINUS: xloc -= charMatrixHeight;
		break;
		case XPLUS: xloc += charMatrixHeight;
		break;
		case ZPLUS: zloc += charMatrixHeight;
		break;
		case ZMINUS: zloc -= charMatrixHeight;
		break;
		}

		return(new Location(world, xloc, yloc, zloc));
	}
	
	private DyeColor mapTimeToColor(int value) {
		if (value > 50) {
			return(DyeColor.LIGHT_BLUE);  // blue
		} else if (value > 20) {
			return(DyeColor.SILVER);  // Light gray
		} else {
			return(DyeColor.WHITE);  // White
		}
	}

	public void modLetter(boolean erase) {
		Block b = null;
    	World world = myLoc.getWorld();   	 
    	int xloc = myLoc.getBlockX();   
    	int yloc = myLoc.getBlockY();    
    	int zloc = myLoc.getBlockZ();
		
		for (int x = 0; x < charMatrixHeight; x++) {
			for (int z = 0; z < charMatrixWidth; z++) {
				if (myMatrix[x][z] > drawThreshold) {
					switch(myOrientation) {
					case XMINUS: b = myUpright ? world.getBlockAt(xloc+charMatrixHeight-x,yloc-charMatrixWidth+z,zloc) : 
						world.getBlockAt(xloc+charMatrixHeight-x,yloc,zloc+charMatrixWidth-z);
					break;
					case XPLUS: b = myUpright ? world.getBlockAt(xloc+x,yloc-charMatrixWidth+z,zloc) : 
						world.getBlockAt(xloc+x,yloc,zloc+z);
					break;
					case ZPLUS: b = myUpright ? world.getBlockAt(xloc,yloc-charMatrixWidth+z,zloc+x) : 
						world.getBlockAt(xloc+charMatrixWidth-z,yloc,zloc+x);
					break;
					case ZMINUS: b = myUpright ? world.getBlockAt(xloc,yloc-charMatrixWidth+z,zloc+charMatrixHeight-x) : 
						world.getBlockAt(xloc+z,yloc,zloc+charMatrixHeight-x);
					break;
					}
            		if (b.getType() == myMaterial && erase) {
            			b.setType(Material.AIR);
            		} else if (b.getType() == Material.AIR && !erase) {
            			b.setType(myMaterial);
            			if (myMaterial == Material.WOOL) {
            				b.setData(mapTimeToColor(myMatrix[x][z]).getData());  
            			}
            		} else {
            			myMatrix[x][z] = 0;
            		}
				} 
			}
		}		
	}
	
	public void makeLetter() {
		modLetter(false);
	}
	
	public void eraseLetter() {
		modLetter(true);
	}
		
	public MatrixLetter(char c, Location loc, Orientation o, int agespeed, boolean disp, Material m, boolean upright) {
		setLocation(loc);
		setTime(0);
		setOrientation(o);
		myAgeSpeed = agespeed;
		myDisperse = disp;
		myMaterial = m;
		myUpright = upright;

		setLetter(c);		
		makeLetter();
	}
}
